:PROPERTIES:
:ID:       164c8a06-938f-4a39-8f04-989878eabc09
:END:
#+title: pyqt
#+date: [2024-06-28 五]
#+last_modified: [2024-07-05 五 01:26]


| Qt6 模块                    |   |
|----------------------------+---|
| Qt Concurrent              |   |
| Qt Core                    |   |
| Qt Core Compatability APIs |   |
| Qt D-Bus                   |   |
| Qt GUI                     |   |
| Qt Help                    |   |
| Qt Network                 |   |
| Qt OpenGL                  |   |
| Qt Print Support           |   |
| Qt QML                     |   |
| Qt Quick                   |   |
| Qt Quick 3D                |   |
| Qt Quick Controls          |   |
| Qt Qucik Layouts           |   |
| Qt Quick Timeline          |   |
| Qt Qucik Widgets           |   |
| Qt Shader Tools            |   |
| Qt SQl                     |   |
| Qt SVG                     |   |
| Qt Test                    |   |
| Qt UI Tools                |   |
| Qt Wayland                 |   |
| Qt Wayland Compositor      |   |
| Qt Widgets                 |   |
| Qt XML                    |   |
| Qt 3D                      |   |
| Qt Image Formats           |   |
| Qt Network Authorization   |   |
| M2M package Qt CoAp        |   |
| M2M package Qt MQTT        |   |
| M2M package Qt OpcUA       |   |







#+begin_src python
import sys
from PyQt6.QtWidgets import QApplication, QMainWindow, QPushButton

class MainWin(QMainWindow):
    __mySize=None
    def __init__(self, parent=None):
        super(MainWin, self).__init__(parent)
        # 设置窗口属性
        self.resize(400, 200)
        self.setWindowTitle('主窗口居中显示')
        self.myCenter()
        
        self.btn = QPushButton(self)
        self.btn.setText('关闭主窗口')
        self.btn.move(int(self.__mySize.width()/2-self.btn.width()/2), \
                      int(self.__mySize.height()/2-self.btn.height()/2) )
        self.btn.clicked.connect(self.onButtonClick)

    def myCenter(self):
        # PyQt6获取屏幕参数
        screen = QApplication.primaryScreen().size()      
        self.__mySize = self.geometry()
        self.move(int((screen.width() - self.__mySize.width())/ 2),
                  int((screen.height() - self.__mySize.height()) / 2))
    def onButtonClick(self ):
        mySender = self.sender()            # sender()获取发送信号的对象
        print(mySender.text()+'控件')     
        # App = QApplication.instance()
        app.quit()
		
if __name__ == '__main__':
    app = QApplication(sys.argv)
    m = MainWin()
    m.show()
    sys.exit(app.exec())
#+end_src

#+RESULTS:



#+begin_src python
import sys
from PyQt6.QtWidgets import QApplication, QMainWindow, QDialog, QPushButton

class MainWin(QMainWindow):
    mySize=None
    def __init__(self, parent=None):
        super(MainWin, self).__init__(parent)
        # 设置窗口属性
        self.resize(400, 200)
        self.setWindowTitle('主窗口居中显示')
        self.myCenter()
        
        self.btn = QPushButton(self)
        self.btn.setText('关闭主窗口')
        self.btn.move(150,80)
        self.btn.clicked.connect(self.onButtonClick)

    def myCenter(self):
        # PyQt6获取屏幕参数
        screen = QApplication.primaryScreen().size()
        mySize = self.geometry()
        self.move(int((screen.width() - mySize.width()) / 2),
                  int((screen.height() - mySize.height()) / 2))
    def onButtonClick(self ):
        mySender = self.sender()            # sender()获取发送信号的对象
        print(mySender.text()+'控件')     
        App = QApplication.instance()
        App.quit()
		
if __name__ == '__main__':
    app = QApplication(sys.argv)
    m = MainWin()
    m.show()
    sys.exit(app.exec())
#+end_src




#+begin_src python
  import sys
  <<pyqt>>

  class MyWindow(QWidget):
      def __init__(self):
	  super(MyWindow, self).__init__()
	  self.setWindowTitle("QMessageBox例子")
	  self.resize(300, 100)
	  self.myButton = QPushButton(self)
	  self.myButton.setText("点击弹出消息框")
	  self.myButton.clicked.connect(self.msg)
      def msg(self):
	  # 使用 information 信息框
	  reply = QMessageBox.information(self,"标题","消息正文",QMessage.Yes | QMessage.No, QMessage.Yes)
	  print(reply)

  if __name__=='__main__':
      app = QApplication(sys.argv)
      w = MyWindow()
      w.show()
      sys.exit(app.exec())
#+end_src







#+begin_src python
import sys
<<pyqt>>
class myWidget(QWidget):
	def __init__(self):
		super().__init__()
		self.initUI()
	def initUI(self):
		self.setWindowTitle("QTableWidget测试")
		self.resize(400, 300);
		tableWidget = QTableWidget(6,4)
		tableWidget.setHorizontalHeaderLabels (['课程号','课程名','课时','学分'])
		#tableWidget.setVerticalHeaderLabels(['A', 'A', 'A', 'B', 'B', 'B'])

		#tableWidget.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)
		#tableWidget.verticalHeader().setVisible(False)
		#tableWidget.horizontalHeader().setVisible(False)
		#tableWidget.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
		#tableWidget.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)
		#tableWidget.resizeColumnsToContents()from PyQt6 import QtCore, QtGui, QtWidgets
from PyQt6.QtCore import Qt


		#tableWidget.resizeRowsToContents()

		newItem = QTableWidgetItem("1A001"); tableWidget.setItem(0,0,newItem)
		newItem = QTableWidgetItem("C++");	tableWidget.setItem(0,1,newItem)
		newItem = QTableWidgetItem("120");	tableWidget.setItem(0,2,newItem)
		newItem = QTableWidgetItem("6");  tableWidget.setItem(0,3,newItem)

		#tableWidget.setSpan(2, 0, 3, 1)
		#newItem = QTableWidgetItem(QIcon("./images/荷花.jpg"), "荷花开放")
		#tableWidget.setItem(1, 3, newItem)

		hLayout =  QHBoxLayout()
		hLayout.addWidget(tableWidget)
		self.setLayout(hLayout)

		tableWidget.itemClicked.connect(self.getItem)
	def getItem(self, item):
		print(item.text())

if __name__=='__main__':
	app = QApplication(sys.argv)
	w=myWidget()
	w.show()
	sys.exit(app.exec())
#+end_src



#+begin_src python
  import sys
  <<pyqt>>

  class myWidget(QWidget):
      def __init__(self):
	  super().__init__()
	  self.initUI()

      def initUI(self):
	  self.setWindowTitle("QTableWidget测试")
	  self.resize(600, 800);

	  tableWidget = QTableWidget(10,2)
	  list=[('计算机导论',1),('高等数学',1),('英语',1),('C++',2),('数据结构',3),('Java',3),\
		('操作系统',3),('仓颉语言',4),('软件工程',4),('计算机网络',5)]

	  for i in range(10):
	      tableWidget.setItem(i, 0, QTableWidgetItem(list[i][0]))
	      tableWidget.setItem(i, 1, QTableWidgetItem(str(list[i][1])))

	  tableWidget.horizontalHeader().setVisible(False)
	  tableWidget.sortItems(1,QtCore.Qt.SortOrder.DescendingOrder)

	  layout = QHBoxLayout()
	  layout.addWidget(tableWidget)
	  self.setLayout(layout)

	  # 查找对应的单元格
	  text = '仓颉语言'
	  items = tableWidget.findItems(text, QtCore.Qt.MatchFlag.MatchExactly)
	  item = items[0]

	  # 设置定位的单元格的背景颜色为红色
	  item.setFont(QFont("黑体", 14))
	  item.setForeground(QBrush(QColor(255, 0, 0)))
	  # 滚动到定位的单元格行
	  row = item.row()
	  tableWidget.verticalScrollBar().setSliderPosition(row)

  if __name__ == '__main__':
      app = QApplication(sys.argv)
      w = myWidget()
      w.show()
      sys.exit(app.exec())
#+end_src


#+begin_src python
  import sys
  <<pyqt>>

  class myWidget(QWidget):
	  def __init__(self):
		  super().__init__()
		  self.initUI()
	  def initUI(self):
		  self.setWindowTitle("QTableWidget测试")
		  self.resize(400, 300)
		  self.tableWidget = QTableWidget(6,4)
		  self.tableWidget.setHorizontalHeaderLabels (['课程号','课程名','课时','学分'])

		  newItem = QTableWidgetItem("1A001"); self.tableWidget.setItem(0,0,newItem)
		  newItem = QTableWidgetItem("C++");	self.tableWidget.setItem(0,1,newItem)
		  newItem = QTableWidgetItem("1A002"); self.tableWidget.setItem(1,0,newItem)
		  newItem = QTableWidgetItem("Java");	self.tableWidget.setItem(1,1,newItem)

		  hLayout =  QHBoxLayout()
		  hLayout.addWidget(self.tableWidget)
		  self.setLayout(hLayout)
		  # (1) 右键产生子菜单, 关联槽函数
		  self.tableWidget.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
		  self.tableWidget.customContextMenuRequested.connect(self.generateMenu)

	  def generateMenu(self, pos):
		  # (2)
		  row_num = -1
		  for i in self.tableWidget.selectionModel().selection().indexes():
			  row_num = i.row()
		  # (3)
		  if row_num < 4:
			  menu = QMenu()
			  m1 = menu.addAction("课程编号")
			  m2 = menu.addAction("课程名")
			  m3 = menu.addAction("课程信息")
			  # (4)
			  action = menu.exec(self.tableWidget.mapToGlobal(pos))
			  # (5)
			  if action == m1:
				  print('课程编号：', self.tableWidget.item(row_num, 0).text())
			  elif action == m2:
				  print('课程名：', self.tableWidget.item(row_num, 1).text())
			  elif action == m3:
				  print('课程信息：', self.tableWidget.item(row_num, 0).text(), \
					    self.tableWidget.item(row_num, 1).text(),end='  ')
				  try:
					  print(self.tableWidget.item(row_num, 2).text(),end='  ')
				  except:	pass
				  try:
					  print(self.tableWidget.item(row_num, 3).text())
				  except:  print('\n')

  if __name__=='__main__':
	  app = QApplication(sys.argv)
	  w=myWidget()
	  w.show()
	  sys.exit(app.exec())
#+end_src


#+begin_src python
import sys
from PyQt6.QtGui import QStandardItemModel, QStandardItem
from PyQt6.QtWidgets import (QApplication, QMainWindow, QTreeView, QStyleFactory)

class mainWin(QMainWindow):
    def __init__(self, parent=None):
        super(mainWin, self).__init__(parent)
        self.setWindowTitle('QTreeView测试')
        self.resize(520, 360)
        self.initUi()

    def initUi(self):
        # 设置节点头信息
        item = QStandardItemModel(self)
        item.setHorizontalHeaderLabels(['南京师范大学', '创始于1902年，国家“双一流”建设高校'])

        # 添加学院
        itemXy1 = QStandardItem('计算机与电子信息学院')
        item.appendRow(itemXy1)
        item.setItem(0, 1, QStandardItem('1984年创办计算机专业'))
        # 添加学院系
        itemXi1 = QStandardItem('计算机科学与技术系')
        itemXy1.appendRow(itemXi1)
        itemXy1.setChild(0, 1, QStandardItem('系信息'))

        itemCy1 = QStandardItem('成员1')
        itemCy1.setCheckable(True)
        itemXi1.appendRow(itemCy1)
        itemXi1.setChild(itemCy1.index().row(), 1, QStandardItem('成员{}信息说明'.format(0 + 1)))

        itemCy2 = QStandardItem('成员2')
        itemCy2.setCheckable(True)
        itemXi1.appendRow(itemCy2)
        itemXi1.setChild(itemCy2.index().row(), 1, QStandardItem('成员{}信息说明'.format(1 + 1)))

        itemXi2 = QStandardItem('人工智能系')
        itemXy1.appendRow(itemXi2)

        itemXy2 = QStandardItem('电气与自动化工程学院')
        item.appendRow(itemXy2)
        item.setItem(1, 1, QStandardItem('学院信息'))

        treeView = QTreeView(self)
        treeView.setModel(item)
        treeView.header().resizeSection(0, 160)                 # 调整第一列的宽度
        treeView.setStyle(QStyleFactory.create('windows'))      # 设置为有虚线连接的方式
        treeView.expandAll()                                    # 完全展开

        # 选中行信号关联槽函数
        treeView.selectionModel().currentChanged.connect(self.onCurrentChanged)
        self.setCentralWidget(treeView)

    def onCurrentChanged(self, current, previous):
        txt = '学院:[{}] '.format(str(current.parent().data()))
        txt += '当前选择:[(行{},列{})] '.format(current.row(), current.column())

        name = ''; info = ''
        if current.column() == 0:
            name = str(current.data())
            info = str(current.sibling(current.row(), 1).data())
        else:
            name = str(current.sibling(current.row(), 0).data())
            info = str(current.data())
        # 状态栏显示选择行信息
        txt += '名称:[{}]  信息:[{}]'.format(name, info)
        self.statusBar().showMessage(txt)

if __name__ == '__main__':
    app = QApplication(sys.argv)
    m = mainWin()
    m.show()
    sys.exit(app.exec())
#+end_src



#+begin_src python
  import sys
  <<pyqt>>

  if __name__ == '__main__':
      app = QApplication(sys.argv)
      # Window系统提供的模式
      model = QFileSystemModel()
      dir="/home/lyt0628/"
      model.setRootPath(dir)
      # 为树添加Window系统提供的模式
      tree = QTreeView()
      tree.setModel(model)
      # 设置树属性
      tree.setWindowTitle("QTreeView测试")
      tree.setAnimated(False)
      tree.setIndentation(20)
      tree.setSortingEnabled(True)
      tree.setColumnWidth(0,200)
      tree.expandAll()
      tree.resize(640, 480)

      tree.show()
      sys.exit(app.exec())
#+end_src


#+begin_src python
import sys
<<pyqt>>
class mainWin(QMainWindow):
    def __init__(self, parent=None):
        super(mainWin, self).__init__(parent)
        self.setWindowTitle('TreeWidget测试')
        # 设置根节点
        JC = QTreeWidgetItem()
        #JC = QTreeWidgetItem(self.treeWidget)
        JC.setText(0, '南京部分大学')
        # 设置一级子节点3个
        JC_nju = QTreeWidgetItem(JC)
        JC_nju.setText(0, '南京大学')
        JC_nju.setText(1, '江苏省南京市栖霞区仙林大道163号')
        JC_nju.setIcon(0, QIcon("./images/dx/nju.jpg"))

        JC_seu = QTreeWidgetItem(JC)
        JC_seu.setText(0, '东南大学')
        JC_seu.setText(1, '南京市江宁区东南大学路2号')
        JC_seu.setIcon(0, QIcon("./images/dx/seu.jpg"))

        JC_njnu = QTreeWidgetItem(JC)
        JC_njnu.setText(0, '南京师范大学')
        JC_njnu.setText(1, '江苏省南京市栖霞区文苑路1号')
        JC_njnu.setIcon(0, QIcon("./images/dx/njnu.jpg"))

        # 设置二级子节点2个
        JC_njnu_jsj = QTreeWidgetItem(JC_njnu)
        JC_njnu_jsj.setText(0, '计算机与电子信息学院')
        JC_njnu_jsj.setText(1, '明理楼')
        # 设置节点的背景颜色
        blue = QBrush(Qt.GlobalColor.blue)
        JC_njnu_jsj.setBackground(0, blue)
        JC_njnu_jsj.setCheckState(0, Qt.CheckState.Checked)

        JC_njnu_dq = QTreeWidgetItem(JC_njnu)
        JC_njnu_dq.setText(0, '电气与自动化工程学院')

        self.treeWidget = QTreeWidget()
        self.treeWidget.setColumnCount(2)                       # 设置列数
        self.treeWidget.setColumnWidth(0, 160)
        self.treeWidget.setHeaderLabels(['名称', '地址'])         # 设置头的标题
        # JC节点加入树顶层
        self.treeWidget.addTopLevelItem(JC)
        # 结点全部展开
        self.treeWidget.expandAll()
        #  树在主窗口显示
        self.setCentralWidget(self.treeWidget)
        self.treeWidget.clicked.connect(self.onTreeClicked)

    def onTreeClicked(self, qmodelindex):
        item = self.treeWidget.currentItem()
        print("名称=%s ,地址=%s" % (item.text(0), item.text(1)))

if __name__ == '__main__':
    app = QApplication(sys.argv)
    w = mainWin()
    w.show()
    sys.exit(app.exec())
#+end_src



#+begin_src python
import sys
<<pyqt>>
class myWidget(QWidget):
    def __init__(self, parent=None):
        super(myWidget, self).__init__(parent)
        self.setWindowTitle('TreeWidget测试')

        hLayBtn = QHBoxLayout()
        pbAdd = QPushButton("添加")
        pbUpdate = QPushButton("修改")
        pbDel = QPushButton("删除")
        # 按钮单击信号关联槽函数
        pbAdd.clicked.connect(self.addTreeNode)
        pbUpdate.clicked.connect(self.updateTreeNode)
        pbDel.clicked.connect(self.delTreeNode)

        hLayBtn.addWidget(pbAdd)
        hLayBtn.addWidget(pbUpdate)
        hLayBtn.addWidget(pbDel)

        self.tree = QTreeWidget(self)
        # 设置列数
        self.tree.setColumnCount(1)
        # 设置头的标题
        self.tree.setHeaderLabels(['名称'])

        root = QTreeWidgetItem(self.tree)
        root.setText(0, '学校')

        child1 = QTreeWidgetItem(root)
        child1.setText(0, '学院1')

        child2 = QTreeWidgetItem(root)
        child2.setText(0, '学院2')

        child3 = QTreeWidgetItem(child2)
        child3.setText(0, '1系')

        self.tree.addTopLevelItem(root)
        self.tree.expandAll()

        vLayout = QVBoxLayout(self)
        self.le=QLineEdit()
        vLayout.addWidget(self.le)
        vLayout.addLayout(hLayBtn)
        vLayout.addWidget(self.tree)
        self.setLayout(vLayout)

    def addTreeNode(self):
        item = self.tree.currentItem()
        newNode = QTreeWidgetItem(item)
        txt = self.le.text()
        if txt != '':
            newNode.setText(0, txt)

    def updateTreeNode(self):
        item = self.tree.currentItem()
        txt = self.le.text()
        if txt != '':
            item.setText(0, txt)

    def delTreeNode(self):
        item = self.tree.currentItem()
        root = self.tree.invisibleRootItem()
        for item in self.tree.selectedItems():
            (item.parent() or root).removeChild(item)

if __name__ == '__main__':
    app = QApplication(sys.argv)
    w = myWidget()
    w.show()
    sys.exit(app.exec())
#+end_src



#+begin_src python
import sys
<<pyqt>>
import numpy as np


class myChart(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('二维图表')
        # self.showLine()
        # self.showBar()
        self.showPie()

    def showLine(self):
        #（1）创建图表和视图
        chart = QChart()
        chart.setTitle('螺旋曲线')
        chartView = QChartView(self)#必须有self,才能在界面上显示图表
        chartView.setGeometry(10, 10, 800, 600)
        chartView.setChart(chart)

        #（2）创建序列并添加数据
        n = 1000
        pointList = np.linspace(1, 10 * 2 * np.pi, n)

        lSeries1 = QLineSeries()
        lSeries1.setName('Archimedes')
        for t in pointList:
            x = (1 + 0.618 * t) * np.cos(t)
            y = (1 + 0.618 * t) * np.sin(t)
            lSeries1.append(x, y)
        chart.addSeries(lSeries1)

        lSeries2 = QLineSeries()
        lSeries2.setName('hyperbolic')
        for t in pointList:
            x = 10 * 2 * np.pi * (np.cos(t) / t)
            y = 10 * 2 * np.pi * (np.sin(t) / t)
            lSeries2.append(x, y)
        chart.addSeries(lSeries2)

        #（3）建立坐标轴
        chart.createDefaultAxes()

    def showBar(self):
        #（1）创建图表和视图
        chart = QChart()
        chart.setTitle('2017～2021年高考人数和录取率')
        chart.legend().setAlignment(Qt.AlignmentFlag.AlignTop)
        chartView = QChartView(self)#必须有self,才能在界面上显示图表
        chartView.setGeometry(10, 10, 800, 600)
        chartView.setChart(chart)

        #（2）创建序列并添加数据
        number_signup = [940, 975, 1031, 1071, 1078]
        signupSet = QBarSet('报考')
        for i in range(0, 5):
            signupSet << number_signup[i]
        number_enroll = [700, 791, 820, 967.5, 689]
        enrollSet = QBarSet('录取')
        for i in range(0, 5):
            enrollSet << number_enroll[i]

        bSeries = QBarSeries()
        bSeries.append(signupSet)
        bSeries.append(enrollSet)
        bSeries.setLabelsVisible(True)
        bSeries.setLabelsPosition(QAbstractBarSeries.LabelsPosition.LabelsInsideEnd)
        chart.addSeries(bSeries)

        lSeries = QLineSeries()
        lSeries.setName('趋势')
        for i in range(0, 5):
            lSeries.append(i, number_enroll[i])
        pen = QPen(Qt.GlobalColor.red)
        pen.setWidth(2)
        lSeries.setPen(pen)
        lSeries.setPointLabelsVisible(True)
        lSeries.setPointLabelsFormat('@yPoint 万')
        chart.addSeries(lSeries)

        #（3）建立和设置坐标轴
        year = ['2017', '2018', '2019', '2020', '2021']
        axisX = QBarCategoryAxis()
        axisX.setTitleText('年份')
        axisX.append(year)
        chart.addAxis(axisX, Qt.AlignmentFlag.AlignBottom)
        bSeries.attachAxis(axisX)
        lSeries.attachAxis(axisX)

        axisY = QValueAxis()
        axisY.setTitleText('人数（万）')
        chart.addAxis(axisY, Qt.AlignmentFlag.AlignLeft)
        bSeries.attachAxis(axisY)
        lSeries.attachAxis(axisY)

    def showPie(self):
        #（1）创建图表和视图
        chart = QChart()
        chart.setTitle('中国高等教育普及率')
        chart.legend().setAlignment(Qt.AlignmentFlag.AlignLeft)
        chartView = QChartView(self)#必须有self,才能在界面上显示图表
        chartView.setGeometry(10, 10, 800, 600)
        chartView.setChart(chart)

        #（2）创建序列并添加数据
        pieSet = {'儿童和老人': 35, '劳动人口': 49, '参加高考者': 7, '大学生': 8}

        pSeries = QPieSeries()
        for item in pieSet.items():
            pSeries.append(item[0] + '（%d' % item[1] + '%）', item[1])
        pSeries.setLabelsVisible(True)
        pSeries.setHoleSize(0.2)
        pSeries.setPieSize(0.6)

        slice = pSeries.slices()[3]
        slice.setExploded(True)
        slice.setPen(QPen(Qt.GlobalColor.red, 2))
        slice.setBrush(Qt.GlobalColor.red)

        chart.addSeries(pSeries)


if __name__ == '__main__':
    app = QApplication(sys.argv)
    w = myChart()
    w.show()
    sys.exit(app.exec())
#+end_src


#+begin_src python
import sys
from PyQt6.QtCore import Qt
from PyQt6.QtGui import QVector3D, QLinearGradient
from PyQt6.QtWidgets import QApplication, QWidget, QMainWindow
# -*- QtDataVisualization 3D绘图相关类 -*-
from PyQt6.QtDataVisualization import Q3DSurface, QSurface3DSeries, QSurfaceDataProxy, QSurfaceDataItem, QValue3DAxis, Q3DCamera, Q3DTheme

import math


class myData3D(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('三维图表')
        self.showSurface()

    def showSurface(self):
        #（1）创建三维图表和容器
        surface = Q3DSurface()
        container = QWidget.createWindowContainer(surface)
        self.setCentralWidget(container)
        cameraView = Q3DCamera.CameraPreset.CameraPresetFrontHigh
        surface.scene().activeCamera().setCameraPreset(cameraView)

        #（2）封装数据
        proxy = QSurfaceDataProxy()
        N = 400
        x = -20.0
        for i in range(1, N + 1):
            itemRow = []
            y = -20.0
            for j in range(1, N + 1):
                z = math.cos(math.sqrt(x * x + y * y)) * 2.5
                vect3D = QVector3D(x,z,y)
                item = QSurfaceDataItem(vect3D)
                itemRow.append(item)
                y = y + 0.1
            x = x + 0.1
            proxy.addRow(itemRow)
        surSeries = QSurface3DSeries()
        surSeries.setDataProxy(proxy)
        surSeries.setDrawMode(QSurface3DSeries.DrawFlag.DrawSurface)
        gradient = QLinearGradient()
        gradient.setColorAt(1.0, Qt.GlobalColor.yellow)
        gradient.setColorAt(0.5, Qt.GlobalColor.cyan)
        gradient.setColorAt(0.2, Qt.GlobalColor.red)
        gradient.setColorAt(0.0, Qt.GlobalColor.lightGray)
        surSeries.setBaseGradient(gradient)
        surSeries.setColorStyle(Q3DTheme.ColorStyle.ColorStyleRangeGradient)
        surface.addSeries(surSeries)

        #（3）建立和设置坐标轴
        axisX = QValue3DAxis()
        axisX.setTitle('X')
        axisX.setTitleVisible(True)
        axisX.setRange(-21, 21)
        surface.setAxisX(axisX)

        axisZ = QValue3DAxis()
        axisZ.setTitle('Z')
        axisZ.setTitleVisible(True)
        axisZ.setRange(-21, 21)
        surface.setAxisZ(axisZ)

        axisY = QValue3DAxis()
        axisY.setTitle('Y')
        axisY.setTitleVisible(True)
        axisY.setRange(-10, 10)
        surface.setAxisY(axisY)


if __name__ == '__main__':
    app = QApplication(sys.argv)
    w = myData3D()
    w.show()
    sys.exit(app.exec())
#+end_src


#+begin_src python
import sys
<<pyqt>>
class myDraw(QWidget):
    def __init__(self):
        super(myDraw, self).__init__()
        self.resize(600, 500)
        self.setWindowTitle('绘制各种图形')

    def paintEvent(self, event):
        painter = QPainter()
        painter.begin(self)
        # 创建画笔，设置笔为蓝色
        pen = QPen()
        color = Qt.GlobalColor.blue
        pen.setColor(color)
        painter.setPen(pen)
        # 绘制弧: 30度开始120度
        rect = QRect(20, 30, 100, 100)
        painter.drawArc(rect, 30*16, 120*16)
        # 绘制含弦弧: 30度开始120度
        painter.drawChord(150, 30, 100, 100, 30*16, 120*16)
        # 绘制扇形: 30度开始120度
        painter.drawPie(280, 30, 100, 100, 30*16, 120*16)
        # 绘制圆
        painter.drawArc(20, 130, 100, 100, 0, 360*16)
        painter.drawEllipse(150, 130, 100, 100)
        # 绘制椭圆
        painter.drawEllipse(280, 130, 150, 100)
        # 设置笔为红色
        painter.setPen(Qt.GlobalColor.red)
        #绘制方框
        painter.drawRect(20, 260,150,100)

        point1 = QPoint(200, 260)
        point2 = QPoint(200, 360)
        point3 = QPoint(400, 360)
        # 创建多边形对象，绘制多边形对象
        #painter.drawPolygon(point1, point2, point3)
        painter.drawPolyline(point1, point2, point3)
        painter.end()

if __name__ == "__main__":
    app = QApplication(sys.argv)
    w = myDraw()
    w.show()
    sys.exit(app.exec())
#+end_src



#+begin_src python
import sys
from PyQt6.QtWidgets import QApplication,QWidget
from PyQt6.QtCore import Qt,QRect
from PyQt6.QtGui import (QPainter,QPen,QBrush,QPalette,QColor,QFont,QImage)

class myWidget(QWidget):
    def __init__(self,parent=None):
        super().__init__(parent)
        self.setPalette(QPalette(Qt.GlobalColor.white)) #设置窗口背景颜色为白色
        self.setAutoFillBackground(True)
        self.resize(600,360)
        self.setWindowTitle("QPainter基本绘图")

    def paintEvent(self, event): #在窗口上绘图
        painter=QPainter(self)
        # 设置图形和文本抗锯齿
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        painter.setRenderHint(QPainter.RenderHint.TextAntialiasing)
        # 设置画笔
        pen=QPen()
        pen.setWidth(3)                         # 线宽3像素
        pen.setStyle(Qt.PenStyle.DotLine)       # 虚线
        #painter.setPen(pen)
        painter.setPen(Qt.PenStyle.NoPen)
        # 设置画刷
        brush = QBrush()
        brush.setColor(Qt.GlobalColor.yellow)
        brush.setStyle(Qt.BrushStyle.SolidPattern)  # 填充样式
        painter.setBrush(brush)

        # 绘图
        rect=QRect(20, 30, 200, 100)
        painter.drawRect(rect)

        pen.setWidth(1)                             # 线宽1像素
        pen.setStyle(Qt.PenStyle.SolidLine)         # 实线类型
        pen.setColor(Qt.GlobalColor.red)            # 红颜色
        painter.setPen(pen)

        brush.setColor(Qt.GlobalColor.blue)
        brush.setStyle(Qt.BrushStyle.BDiagPattern)  # 填充样式
        painter.setBrush(brush)
        painter.drawPie(280, 30, 200, 100, 30 * 16, 300 * 16)

        rect = QRect(20, 150, 240, 100)
        text = "文本内容ABCD1234"
        pen.setColor(QColor(0, 255, 3))
        painter.setPen(pen)
        painter.setFont(QFont('楷体', 20))            # 设置字体
        painter.drawText(rect, Qt.AlignmentFlag.AlignCenter, text)

        image = QImage("images\荷花.jpg")
        rect = QRect(280, 150, int(image.width()*0.9), image.height())
        painter.drawImage(rect, image)

if __name__ == "__main__":
    app=QApplication(sys.argv)
    w=myWidget()
    w.show()
    sys.exit(app.exec())
#+end_src


#+begin_src python
import sys
from PyQt6.QtCore import Qt, QPoint, QTime, QTimer,QDate,QRect
from PyQt6.QtGui import QColor, QPainter, QPolygon,QFont, QRegion
from PyQt6.QtWidgets import  QApplication, QWidget

class myClock(QWidget):
    # 时针形状
    hourShape = QPolygon([QPoint(6,10),QPoint(-6,10),QPoint(0,-45)])
    # 分针形状
    minuteShape = QPolygon([QPoint(6,10),QPoint(-6,10),QPoint(0,-70)])
    # 时分秒针颜色
    hourColor = QColor(0, 255, 0)
    minuteColor = QColor(0, 0, 255)
    secondColor = QColor(255, 0, 0)
    def __init__(self):
        super().__init__()
        self.setWindowTitle('绘图综合：实时时钟')
        # 创建定时器, 每秒刷新
        timer = QTimer(self)
        timer.timeout.connect(self.update)
        timer.start(1000)
    def paintEvent(self, event):
        time = QTime.currentTime()
        date = QDate.currentDate()
        year=date.year()
        month = date.month()
        day=date.day()
        ymd=str(year)+'年'+str(month)+'月'+str(day)+'日'
        rect= QRect(220,150,200,30)

        painter = QPainter(self)
        painter.setFont(QFont('黑体',24))
        painter.drawText(rect,Qt.AlignmentFlag.AlignCenter,ymd)

        painter.setRenderHint(QPainter.RenderHint.Antialiasing) #抗锯齿
        side = min(self.width(), self.height())
        painter.translate(self.width()/2, self.height()/2)      #平移到窗口中心点
        painter.scale(side/200.0, side/200.0)                   # 缩放比例
        # 绘制小时刻度
        painter.setPen(myClock.hourColor)
        for i in range(12):
            painter.drawLine(88, 0, 96, 0)
            painter.rotate(30.0)
        # 绘制分针刻度
        painter.setPen(myClock.minuteColor)
        for j in range(60):
            if (j % 5) != 0:
                painter.drawLine(94, 0, 96, 0)
            painter.rotate(6.0)
        # 绘制时针
        painter.setPen(Qt.PenStyle.NoPen)
        painter.setBrush(myClock.hourColor)
        painter.save()
        painter.rotate(30.0 * ((time.hour() + time.minute() / 60.0))) # 旋转时针到正确位置
        painter.drawPolygon(myClock.hourShape)
        painter.restore()
        # 绘制分针
        #painter.setPen(Qt.PenStyle.NoPen)
        painter.setBrush(myClock.minuteColor)
        painter.save()
        painter.rotate(6.0 * (time.minute() + time.second() / 60.0))
        painter.drawConvexPolygon(myClock.minuteShape)
        painter.restore()
        # 绘制秒针
        painter.setPen(Qt.PenStyle.NoPen)
        painter.setBrush(myClock.secondColor)
        painter.drawEllipse(-4, -4, 8, 8)
        painter.save()
        painter.rotate(6.0 * time.second())
        painter.drawRoundedRect(-1, -1, 80, 2, 2, 2)
        painter.restore()

    # def resizeEvent(self, event):
    #     w = self.width()
    #     h = self.height()
    #     side = min(w, h)
    #     # 为窗口设置一个圆形遮罩
    #     maskedRegion = QRegion(w/2 - side/2, h/2 - side/ 2, side, side, QRegion.RegionType.Ellipse)
    #     self.setMask(maskedRegion)

if __name__ == '__main__':
    app = QApplication(sys.argv)
    w = myClock()
    w.show()
    sys.exit(app.exec())
#+end_src



#+begin_src python
from PyQt5.QtCore import Qt
from PyQt6.QtWidgets import QApplication,QWidget
from PyQt6.QtGui import (QPainter,QPainterPath)
import sys

class myWidget(QWidget):
    def __init__(self):
        super().__init__()
        self.initUI()

    def initUI(self):
        self.setGeometry(300, 300, 380, 250)
        self.setWindowTitle('路径绘图测试')
        self.show()

    def paintEvent(self, e):
        p = QPainter()
        p.begin(self)
        p.setRenderHint(QPainter.RenderHint.Antialiasing)
        self.myDrawPath(p)
        p.end()

    def myDrawPath(self, p):
        path1 = QPainterPath()
        path1.addEllipse(50, 150, 150, 75)
        p.fillPath(path1,Qt.GlobalColor.black)
        path = QPainterPath()
        path.moveTo(30, 30)
        path.cubicTo(30, 30, 200, 300, 300, 30)
        path.quadTo(120, 50, 150, 120)
        path.lineTo(350, 200)
        path.connectPath(path1)
        p.drawPath(path)

if __name__ == '__main__':
    app = QApplication(sys.argv)
    w = myWidget()
    sys.exit(app.exec())
#+end_src



#+begin_src python
import sys
from PyQt6.QtWidgets import QApplication, QMainWindow
# -*- matplotlib 绘图库 -*-
import matplotlib as plt
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas

import numpy as np


class myFigure(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('二维图表-matplotlib')
        plt.rcParams['font.sans-serif'] = ['SimHei']    # 显示中文
        plt.rcParams['axes.unicode_minus'] = False  # 显示坐标值负号
        self.showLine()

    def showLine(self):
        #（1）创建图表
        figure = Figure()
        figure.suptitle('螺旋曲线')
        figureCanvas = FigureCanvas(figure)
        self.setCentralWidget(figureCanvas)

        #（2）添加数据和坐标轴
        n = 1000
        t = np.linspace(1, 10 * 2 * np.pi, n)

        axes = figure.add_axes([0.1, 0.1, 0.8, 0.8])

        x1 = (1 + 0.618 * t) * np.cos(t)
        y1 = (1 + 0.618 * t) * np.sin(t)
        axes.plot(x1, y1, label="$Archimedes$")

        x2 = 10 * 2 * np.pi * (np.cos(t) / t)
        y2 = 10 * 2 * np.pi * (np.sin(t) / t)
        axes.plot(x2, y2, label="$hyperbolic$")

        axes.legend()   # 加图例标注


if __name__ == '__main__':
    app = QApplication(sys.argv)
    w = myFigure()
    w.show()
    sys.exit(app.exec())
#+end_src




#+begin_src python
  <<pyqt>>
  import sys

  class Worker(QThread):
      strOutSignal = Signal(str)
      def __init__(self, parent=None):
	  super(Worker, self).__init__(parent)
	  self.working = True
      def run(self):
	  while self.working == True:
	      time = QDateTime.currentDateTime()
	      timeStr = time.toString("yyyy-MM-dd hh:mm:ss dddd")
	      self.strOutSignal.emit(timeStr)        #发出信号
	      self.sleep(1)                          #线程休眠1秒
  class myWidget(QWidget):
      def __init__(self, parent=None):
	  super(myWidget, self).__init__(parent)
	  self.setWindowTitle("QThread线程测试")
	  self.listStr = QListWidget()
	  self.pbStart = QPushButton('开始')
	  layout = QGridLayout(self)
	  layout.addWidget(self.listStr, 0, 0, 1, 2)
	  layout.addWidget(self.pbStart, 1, 1)
	  self.pbStart.clicked.connect(self.threadStart)
	  # 创建线程，关联线程信号到槽函数
	  self.thread = Worker()
	  self.thread.strOutSignal.connect(self.listStrAdd)

      def listStrAdd(self, strInf):
	  self.listStr.addItem(strInf)

      def threadStart(self):
	  self.pbStart.setEnabled(False)
	  self.thread.start()

  if __name__ == "__main__":
      app = QApplication(sys.argv)
      w = myWidget()
      w.show()
      sys.exit(app.exec())
#+end_src




#+begin_src python
import sys
<<pyqt>>
class myWidget(QWidget):
    def __init__(self, parent=None):
        super(myWidget, self).__init__(parent)
        self.setWindowTitle("QTimer应用测试")

        self.label = QLabel('',self)
        self.label.setGeometry(20,20,180,60)
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.showTime)
        self.timer.start(1000)

    def showTime(self):
        time = QDateTime.currentDateTime()                      #获取当前时间
        timeDisplay = time.toString("yyyy-MM-dd hh:mm:ss dddd") #设置时间显示
        self.label.setText(timeDisplay)                         #在标签上显示时间

if __name__ == "__main__":
    app = QApplication(sys.argv)
    w = myWidget()
    w.show()
    QTimer.singleShot(20000, app.quit)                          #20秒退出应用
    sys.exit(app.exec())
#+end_src



* See also
- [[id:0e633ffc-34bc-4f3f-bbe7-6d1428e0f450][PySide]]


<<2>>



#+begin_src python
import sys

from PyQt6 import QtCore, QtGui, QtWidgets
from PyQt6.QtCore import Qt


class _Bar(QtWidgets.QWidget):

    clickedValue = QtCore.pyqtSignal(int)
    # end::Bar[]
    def __init__(self, steps):
        super().__init__()

        self.setSizePolicy(
            QtWidgets.QSizePolicy.Policy.MinimumExpanding,
            QtWidgets.QSizePolicy.Policy.MinimumExpanding,
        )

        if isinstance(steps, list):
            # list of colors.
            self.n_steps = len(steps)
            self.steps = steps

        elif isinstance(steps, int):
            # int number of bars, defaults to red.
            self.n_steps = steps
            self.steps = ["red"] * steps

        else:
            raise TypeError("steps must be a list or int")

        self._bar_solid_percent = 0.8
        self._background_color = QtGui.QColor("black")
        self._padding = 4  # n-pixel gap around edge.

    def sizeHint(self):
        return QtCore.QSize(40, 120)

    def paintEvent(self, e):
        painter = QtGui.QPainter(self)

        brush = QtGui.QBrush()
        brush.setColor(self._background_color)
        brush.setStyle(Qt.BrushStyle.SolidPattern)
        rect = QtCore.QRect(
            0,
            0,
            painter.device().width(),
            painter.device().height(),
        )
        painter.fillRect(rect, brush)

        # Get current state.
        parent = self.parent()
        vmin, vmax = parent.minimum(), parent.maximum()
        value = parent.value()

        # Define our canvas.
        d_height = painter.device().height() - (self._padding * 2)
        d_width = painter.device().width() - (self._padding * 2)

        # Draw the bars.
        step_size = d_height / self.n_steps
        bar_height = step_size * self._bar_solid_percent

        # Calculate the y-stop position, from the value in range.
        pc = (value - vmin) / (vmax - vmin)
        n_steps_to_draw = int(pc * self.n_steps)

        for n in range(n_steps_to_draw):
            brush.setColor(QtGui.QColor(self.steps[n]))
            ypos = (1 + n) * step_size
            rect = QtCore.QRect(
                self._padding,
                self._padding + d_height - int(ypos),
                d_width,
                int(bar_height),
            )
            painter.fillRect(rect, brush)

        painter.end()

    def _trigger_refresh(self):
        self.update()

    # tag::click[]
    def _calculate_clicked_value(self, e):
        parent = self.parent()
        vmin, vmax = parent.minimum(), parent.maximum()
        d_height = self.size().height() + (self._padding * 2)
        step_size = d_height / self.n_steps
        click_y = e.y() - self._padding - step_size / 2

        pc = (d_height - click_y) / d_height
        value = int(vmin + pc * (vmax - vmin))
        self.clickedValue.emit(value)

    def mouseMoveEvent(self, e):
        self._calculate_clicked_value(e)

    def mousePressEvent(self, e):
        self._calculate_clicked_value(e)

    # end::click[]


class PowerBar(QtWidgets.QWidget):
    """
    Custom Qt Widget to show a power bar and dial.
    Demonstrating compound and custom-drawn widget.
    """

    def __init__(self, parent=None, steps=5):
        super().__init__(parent)

        layout = QtWidgets.QVBoxLayout()
        self._bar = _Bar(steps)

        layout.addWidget(self._bar)

        self._dial = QtWidgets.QDial()
        self._dial.valueChanged.connect(self._bar._trigger_refresh)

        # Take feedback from click events on the meter.
        self._bar.clickedValue.connect(self._dial.setValue)

        layout.addWidget(self._dial)
        self.setLayout(layout)

    def __getattr__(self, name):
        if name in self.__dict__:
            return self[name]

        try:
            return getattr(self._dial, name)
        except AttributeError:
            raise AttributeError(
                "'{}' object has no attribute '{}'".format(
                    self.__class__.__name__, name
                )
            )

    def setColor(self, color):
        self._bar.steps = [color] * self._bar.n_steps
        self._bar.update()

    def setColors(self, colors):
        self._bar.n_steps = len(colors)
        self._bar.steps = colors
        self._bar.update()

    def setBarPadding(self, i):
        self._bar._padding = int(i)
        self._bar.update()

    def setBarSolidPercent(self, f):
        self._bar._bar_solid_percent = float(f)
        self._bar.update()

    def setBackgroundColor(self, color):
        self._bar._background_color = QtGui.QColor(color)
        self._bar.update()


app = QtWidgets.QApplication(sys.argv)
volume = PowerBar(
    steps=[
        "#5e4fa2",
        "#3288bd",
        "#66c2a5",
        "#abdda4",
        "#e6f598",
        "#ffffbf",
        "#fee08b",
        "#fdae61",
        "#f46d43",
        "#d53e4f",
        "#9e0142",
    ]
)
volume.show()
app.exec()
#+end_src

#+RESULTS:
: None




#+begin_src python
import sys

from PyQt6 import QtCore, QtGui, QtWidgets
from PyQt6.QtCore import Qt


class _Bar(QtWidgets.QWidget):
    def __init__(self, steps):
        super().__init__()

        self.setSizePolicy(
            QtWidgets.QSizePolicy.Policy.MinimumExpanding,
            QtWidgets.QSizePolicy.Policy.MinimumExpanding,
        )

        if isinstance(steps, list):
            # list of colors.
            self.n_steps = len(steps)
            self.steps = steps

        elif isinstance(steps, int):
            # int number of bars, defaults to red.
            self.n_steps = steps
            self.steps = ["red"] * steps

        else:
            raise TypeError("steps must be a list or int")

        self._bar_solid_percent = 0.8
        self._background_color = QtGui.QColor("black")
        self._padding = 4  # n-pixel gap around edge.

    def sizeHint(self):
        return QtCore.QSize(40, 120)

    # tag::paintEvent[]
    def paintEvent(self, e):
        painter = QtGui.QPainter(self)

        brush = QtGui.QBrush()
        brush.setColor(self._background_color)
        brush.setStyle(Qt.BrushStyle.SolidPattern)
        rect = QtCore.QRect(
            0,
            0,
            painter.device().width(),
            painter.device().height(),
        )
        painter.fillRect(rect, brush)

        # Get current state.
        parent = self.parent()
        vmin, vmax = parent.minimum(), parent.maximum()
        value = parent.value()

        # Define our canvas.
        d_height = painter.device().height() - (self._padding * 2)
        d_width = painter.device().width() - (self._padding * 2)

        # Draw the bars.
        step_size = d_height / self.n_steps
        bar_height = step_size * self._bar_solid_percent

        # Calculate the y-stop position, from the value in range.
        pc = (value - vmin) / (vmax - vmin)
        n_steps_to_draw = int(pc * self.n_steps)

        for n in range(n_steps_to_draw):
            brush.setColor(QtGui.QColor(self.steps[n]))
            ypos = (1 + n) * step_size
            rect = QtCore.QRect(
                self._padding,
                self._padding + d_height - int(ypos),
                d_width,
                int(bar_height),
            )
            painter.fillRect(rect, brush)

        painter.end()

    # end::paintEvent[]

    def _trigger_refresh(self):
        self.update()


class PowerBar(QtWidgets.QWidget):
    """
    Custom Qt Widget to show a power bar and dial.
    Demonstrating compound and custom-drawn widget.
    """

    def __init__(self, parent=None, steps=5):
        super().__init__(parent)

        layout = QtWidgets.QVBoxLayout()
        self._bar = _Bar(steps)

        layout.addWidget(self._bar)

        self._dial = QtWidgets.QDial()
        self._dial.valueChanged.connect(self._bar._trigger_refresh)
        layout.addWidget(self._dial)

        self.setLayout(layout)

    # tag::getattr[]
    def __getattr__(self, name):
        if name in self.__dict__:
            return self[name]

        try:
            return getattr(self._dial, name)
        except AttributeError:
            raise AttributeError(
                "'{}' object has no attribute '{}'".format(
                    self.__class__.__name__, name
                )
            )

    # end::getattr[]

    # tag::methods[]
    def setColor(self, color):
        self._bar.steps = [color] * self._bar.n_steps
        self._bar.update()

    def setColors(self, colors):
        self._bar.n_steps = len(colors)
        self._bar.steps = colors
        self._bar.update()

    def setBarPadding(self, i):
        self._bar._padding = int(i)
        self._bar.update()

    def setBarSolidPercent(self, f):
        self._bar._bar_solid_percent = float(f)
        self._bar.update()

    def setBackgroundColor(self, color):
        self._bar._background_color = QtGui.QColor(color)
        self._bar.update()

    # end::methods[]


app = QtWidgets.QApplication(sys.argv)
volume = PowerBar(
    steps=[
        "#5e4fa2",
        "#3288bd",
        "#66c2a5",
        "#abdda4",
        "#e6f598",
        "#ffffbf",
        "#fee08b",
        "#fdae61",
        "#f46d43",
        "#d53e4f",
        "#9e0142",
    ]
)
volume.show()
app.exec()
#+end_src
